We design a framework for finding incentive flaws in Ethereum PoS system called bunnyfinder. BunnyFinder involves a carefully designed “strategy generator” that generates a large pool of attack instances, an automatic workflow that launches attacks and analyzes the results, and a workflow that fine-tunes the attack parameters to identify the most profitable attacks.As BunnyFinder aims at Ethereum PoS, I will introduce the Ethereum PoS protocol first.
Ethereum PoS assumes that the network is partially synchronous, i.e., there exists an unknown upper bound $\Delta$ for message propagation and processing. In the paper, our analysis focuses on the attacks when the network is synchronous, assuming that $\Delta$ is known by all validators. In Ethereum, time is divided into epochs. Each epoch includes 32 slots where each slot lasts for 12 seconds. For our purpose, we call four seconds (1/3 of a slot) a time  unit.
Validators are the parties that participate in the PoS protocol. Without loss of generality, we assume that there are $n$ validators $\{v_1, v_2, ..., v_n\}$ while in practice $n$ may change over time. Each validator deposits $32$ ETH as its stake. The stake of each validator represents its  weight, which is useful during voting. For simplicity, we assume the weights of all validators are the same.
Among $n$ validators, up to $f$ become Byzantine and fail arbitrarily. Since we assume the weights of all validators are the same, and the number of validators is fixed, Ethereum assumes  $n\geq 3f+1$, which is optimal for partially synchronous consensus protocols.
In this work, we consider an adversary that may control up to $f$ validators, but the actual number of validators controlled might be lower than $f$.
A block $b$ consists of the slot number, a hash pointer to the  parent block in the chain, a batch of transactions, and a set of  attestations. Attestations are the votes of the validators. Each attestation $att$ includes the slot number, the hash of some block, and two hashes of the  checkpoint (cp) blocks, where a checkpoint is a specific block proposed at a certain point of the protocol.
In each epoch, validators are divided into 32 committees and each committee is assigned to only one slot. In each slot, all validators in the corresponding committee become  attestors and become eligible to vote. Also, a single validator is chosen to be the  proposer that is eligible to propose a block. The identities of the committees and proposers are randomly selected and all validators can verify the identities of each other.
Ethereum PoS uses Casper FFG (Friendly Finality Gadget) to  finalize the blocks. A block is considered finalized when it has received a sufficient number of attestations. Once a block is finalized, all blocks led by the block will never be reversed.
Ethereum PoS uses the HLMD GHOST (Hybrid Latest Message Driven Greedy Heaviest Observed Sub-Tree) fork choice rule to determine the  canonical chain. Informally, every proposer extends its canonical chain when it proposes a new block and every attestor votes for its canonical chain. The HLMD GHOST rule selects the  heaviest chain based on the number of attestations. We omit the details as it is not that relevant to our framework.
At the beginning of a slot $t$, a block proposer $v_i$ builds a block $b=\msgp{Propose{t,v_i,H(head),atts,txs}}$. In the block $b$, $t$ is the slot number, $head$ is the output of the fork choice, $atts$ is a set of attestations, and $txs$ is the batch of transactions. After four seconds of slot $t$ has elapsed, each eligible attestor $v_i$ creates an attestation $att=\msgp{Attest}{t,v_i,H(head),H(cp_1),H(cp_2)}$ and sends $att$ to all validators in the same committee. Here, $head$ is the output of the fork choice, and $cp_1$ and $cp_2$ are two checkpoint blocks. After receiving a message $m$ from other validators, $m$ is added into each validator $v_i$'s local block tree $\mathcal{T}$, which is useful only for the fork choice rule.
The incentive mechanism of Ethereum includes both rewards and penalties. Rewards include block rewards, transaction fees, and attestation fees. Block rewards are rewards each block proposer can receive after its proposed blocks are finalized. Transaction fees are the extra fees users pay to complete a transaction. Attestation fees are the fees each attestor receives after its attestations are finalized. Notably, the concrete values of the attestation rewards are related to the  participation rate}, i.e., the total stake that votes for the same block. For example, if attestors that own 75\% stake vote for the same block and their attestations are finalized, these attestors receive 75\% of the maximum attestation reward. Penalties, on the other hand, include the slashing condition and attestation penalties. The slashing condition penalizes validators that equivocate (i.e., validators that propose two conflicting blocks or vote for two conflicting branches). Attestation penalties penalize attestors whose attestations are not finalized (while they are supposed to send these attestations).
Second, I will give a overview of BunnyFinder. BunnyFinder consists of three main components: the  Strategy Generator (SG),  Strategy Executor (SE), and  State Analyzer (SA). In a nutshell, the framework proceeds as follows: the SG generates a set of attack instances; the SE imports these attack instances in our locally deployed Ethereum testnet where a fraction of validators apply the corresponding attack strategies; the SA collects the logs from the validators and analyzes whether each attack instance reveals an incentive flaw. We provide an overview of the design philosophy of each component. In particular, as the strategy generator is crucial in our framework, we discuss how to begin with the basic malicious behaviors of Byzantine validators, develop a large space of attack instances, and how we narrow down the space and determine a shortlist of attack instances. We then discuss how we inject the attack instances and assess the attacks.
In SG, we reduce the space of attack instances.
We first introduce the fundamental attack strategies.
To cause an incentive flaw, there are only two types of malicious behaviors of Byzantine validators: \textit{order manipulation} and \textit{content manipulation}. Order manipulation denotes the strategy that changes the order of the messages each validator sends to other validators. Since Byzantine validators may collude, we use \textit{message queue} to denote the messages each validator is supposed to send. An adversary may modify the message queue arbitrarily and determine when each message is sent to other validators. In addition, content manipulation denotes the strategy that changes the content of the messages. Our current framework studies the incentive flaws that could occur when the network is synchronous. Accordingly, the adversary does not have control over the message queue of honest validators. Although there are only two types of malicious behaviors, the space of the concrete attack instances is enormous. Indeed, each message may be modified arbitrarily and delayed for an arbitrarily long time. Additionally, the adversary may control different fractions of Byzantine validators. As the fraction of validators controlled by the adversary grows, the size of the message queues that need to be manipulated also grows. As we cannot exhaustively enumerate every attack strategy, we need to \textit{optimize} the attack strategies to reduce the space of the attack instances.
Second, we introduce how we optimize the attack strategies.
To reduce the space of possible attack instances, we introduce the following approaches to identify potentially impactful attacks on incentives, which serve as a basis for generating initial instances.
1. Applying the same strategies for \textit{all} Byzantine validators. Instead of varying the strategies for each Byzantine validator, we let all Byzantine validators perform the same strategies in each attack instance. This significantly reduces the attack instances. Indeed, as the fraction of validators controlled by the adversary grows, the number of attack instances does not grow accordingly. While we believe applying different strategies for different Byzantine validators may find some interesting results, we leave it as future work.
2. Optimizing the order manipulation. We implement the following optimization for order manipulation.
    1. Not releasing the message earlier than expected. In the implementation of Ethereum, validators do not process the messages with a slot number higher than its current local slot number. Therefore, releasing a message earlier than expected is meaningless.
    2. Setting up discrete delay time. We set up the delay time of any message discretely where \textit{one unit} is one-third of each slot, i.e., four seconds. We choose this optimization for two reasons. First, every validator triggers some functions at each \textit{unit}, e.g., line 08 of \figref{fig:protocol} shows that each attestor prepares its attestation after four seconds have elapsed in each slot. Second, we consider a synchronous network so all messages are delivered \textit{on time}.
3. Optimizing content manipulation. We show the data structure of a block and an attestation in detail in \figref{code}. We perform the following optimizations for content manipulation.
    1. Block. The \textit{slot} field of the block is an unsigned integer. The \textit{proposer} field denotes the identity of the block proposer. As all validators can verify the identity of the block proposer, these two fields can not be modified. The \textit{parent} field denotes the hash of the parent block. This field can be modified, a trick used by several known attacks~\cite{neuder2021low, unrealized, maxatt, neu2021ebb}. The \textit{transactions} field includes a batch of transactions. This field is irrelevant to the attestation incentives, so we do not consider it in our work. The \textit{attestations} field includes a set of attestations. This field is crucial as each validator determines the \textit{weight} of the branches in its block tree in the fork choice. To summarize, we consider modifying both parent and attestation fields for a block.
    2. Attestation. Similar to the discussion for the block, we consider modifying slot and attestor fields meaningless for an attestation. The \textit{head} field is the hash of each attestor's canonical chain. The head field can be replaced with the hash of the block that is either observed by honest validators or some withheld block being delayed. Meanwhile, the \textit{source} and \textit{target} fields are two checkpoints. Both fields can be modified, a practice conducted by several known attacks~\cite{maxatt, preventionbouncintattack}.
4. We summarize our SG. Based on the optimized attack strategies, we already have a decent number of attack instances. Namely, each Byzantine validator may perform order manipulation, content manipulation, or both. We may also vary the number of Byzantine validators controlled by the adversary to come up with different attack instances. In our strategy generator, we define a \textit{strategy specification format} (SSF) in the form of JSON, specifying the exact time each message should be delayed and what content the message should be modified for the Byzantine validators. SSF file is defined as some JSON templates for both order manipulation and content manipulation. Based on the concrete attack strategies (e.g., the number of units each message should be delayed), the corresponding template is ``filled". To be specific, in each slot, our SSF defines three factors: \hl{slot} denotes the slot Byzantine validators should take the actions; \hl{actions} denotes the actual attack strategies. One SSF file contains all slots' attack strategies in three epoch. The strategy format is shown in JSON. An example of JSON is as follows:
[{
	"slot": "1",
	"actions":{
		"point1": "action1",
		"point2": "action2",
		...
	},
    "slot": "2",
	"actions":{
		"point1": "action1",
		"point2": "action2",
		...
	},
    ...
}]

SE Injecting the Attack Instances. To inject the attack instances, we borrow the idea from software testing tools and use \textit{failure injection} to ``inject" the corresponding attack strategies. SE parses the attack instances written in JSON according to our SSF (generated by SG), and then
translates the corresponding attack strategies to the Byzantine clients. In particular, we add 1,185 new LOC in the \textit{Ethereum client} codebase, making it possible to apply both order manipulation and content manipulation. These codes are mainly located at the functions of block/attestation generation and Broadcast.
SA analyzes the execution results and determines whether the corresponding attack is an incentive flaw. We we define the following metrics to evaluate the attack instances:
1. Both Byzantine and honest validators receive rewards. In this case, the attack is  \textit{meaningful} only when the rewards honest validators receive are lower than their fair share.
2. Both Byzantine and honest validators are penalized. In this case, an attack is already meaningful, as honest validators are penalized while they strictly follow the protocol.
3. Byzantine validators receive rewards, while honest actions are penalized. An attack in this category may create a significant impact on the stability of the system, as the fraction of stake controlled by the adversary continues to grow and may eventually exceed the 33.3\% threshold.
4. Byzantine validators are penalized, while honest validators receive rewards. Similarly, the attack is \textit{meaningful} only when the rewards honest validators receive are lower than their fair share.

Last, I give you the instructions that you should do. First, You should generate the attack strategies for three epochs in SSF structure. Be not afraid to make it complex. Then, I will apply this attack strategies and give the attestation incentive of both honest validators and Byzantine validators to you. Then, you refine your attack strategies based on the result of attack strategies. All
In the first round of Q&A, when generating attack strategies, your responses should be in SSF format only. We list all inject point and possible action.

Inject Point, description, possible actions, description, …
"BlockBeforeBroadCast", the inject point in the function that Byzantine validators from broadcast its block, "return", terminate the Byzantine validators from broadcast its block, "delayWithDuration:x", delay x durations before broadcast (x should be an integer).
"BlockGetNewParentRoot", the inject point in the function that Byzantine validators get the parent block, "modifyParentRoot:x", replace the parent block with the block in slot x (x should be smaller than slot).
"BlockBeforeSign", the inject point in the function that Byzantine validators pack attestations, "packPooledAttest", pack Byzantine attestations
"AttestBeforeBroadCast", the inject point in the function that Byzantine validators from broadcast its attestations, "return", terminate the Byzantine validators from broadcast its attestations, "delayWithDuration:x", delay x durations before broadcast (x should be an integer).
"AttestBeforeSign", the inject point in the function that Byzantine validators create an attestation, "modifyAttestHead:x", replace the head field with the block in slot x (x should be no bigger than slot), "modifyAttestSource:x", replace the source field with the block in slot x (x should be no bigger than slot), "modifyAttestTarget:x",  replace the target field with the block in slot x (x should be no bigger than slot),

Except the first round of Q&A, other questions is a json that shows the results of last strategy. The result is as follows:
["loss rate of honest validators": "x","loss rate of Byzantine validators": "x"]
After receiving the result, generate a new attack strategy according to the result. Note that the slot should start after four epochs of the last strategy. Your responses should also be in SSF format only. Do not conclude.